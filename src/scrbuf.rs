//! Screen bufer - collects what needs to be painted and paints it using the palette.

use crate::{Painter, RGB};

/// Screen buffer - holds one buffer of screen data and paints it on the screen.
pub struct ScreenBuffer {
    width: i32,
    height: i32,
    bytes: Vec<u8>,
    use_sod_palette: bool,
    vert_center: i32,
    dist_from_screen: f64,
    hfov: f64,
}

impl ScreenBuffer {
    /// Create a new screen buffer.
    pub fn new(width: i32, height: i32, use_sod_palette: bool) -> Self {
        assert!(width > 10 && height > 10);
        let len = (width * height) as usize;
        let (dist_from_screen, hfov) = compute_dist_from_screen_and_hfov(width, height);
        let vert_center = height / 2;
        Self {
            width,
            height,
            bytes: vec![0; len],
            use_sod_palette,
            vert_center,
            dist_from_screen,
            hfov,
        }
    }

    /// Screen buffer width.
    #[inline]
    pub fn scr_width(&self) -> i32 {
        self.width
    }

    /// Screen buffer height.
    #[inline]
    pub fn scr_height(&self) -> i32 {
        self.height
    }

    /// Put a pixel in the buffer, *with* transparency.
    #[inline]
    pub fn put_pixel(&mut self, x: i32, y: i32, c: u8) {
        if x >= 0 && y >= 0 && c != 0xFF && x < self.width && y < self.height {
            let idx = y * self.width + x;
            self.bytes[idx as usize] = c;
        }
    }

    /// Fill a rectangle inside the buffer, *without* transparency.
    pub fn fill_rect(&mut self, x: i32, y: i32, w: i32, h: i32, c: u8) {
        if w <= 0 || h <= 0 || x >= self.width || y >= self.height {
            return;
        }

        // shift top-left corner inside the screen
        let xx = Ord::max(x, 0);
        let yy = Ord::max(y, 0);
        let w = w - xx + x;
        let h = h - yy + y;
        if w <= 0 || h <= 0 {
            return;
        }

        // shift bottom right corner inside the screen
        let sw = Ord::min(w, self.width - xx);
        let sh = Ord::min(h, self.height - yy);
        let mut idx = (yy * self.width + xx) as usize;
        let step = self.width - sw;

        // ok to paint
        for _ in 0..sh {
            for _ in 0..sw {
                self.bytes[idx] = c;
                idx += 1;
            }
            idx += step as usize;
        }
    }

    /// Paint the buffer onto the screen.
    pub fn paint(&self, painter: &mut dyn Painter) {
        let mut idx = 0;
        for y in 0..(self.height as i32) {
            for x in 0..(self.width as i32) {
                let color = palette_to_rgb(self.bytes[idx], self.use_sod_palette);
                painter.draw_pixel(x, y, color);
                idx += 1;
            }
        }
    }

    #[inline]
    pub fn get_vert_center(&self) -> i32 {
        self.vert_center
    }

    #[inline]
    pub fn set_vert_center(&mut self, new_center: i32) {
        assert!(new_center > 10);
        assert!(new_center < self.height - 10);
        self.vert_center = new_center;
    }

    #[inline]
    pub fn half_fov(&self) -> f64 {
        self.hfov
    }

    #[inline]
    pub fn screen_x_to_angle(&self, screen_x: i32) -> f64 {
        // I just mirrored the screen horizontally, because map layout is y-flipped :(
        let dx_from_screen_center = (screen_x - self.width / 2) as f64;
        dx_from_screen_center.atan2(self.dist_from_screen)
    }
}

//--------------------------
//  Internal stuff

/// Computes the "virtual" distance from the screen (in "pixels") and half-FOV.
/// Assumes a 4/3 screen ratio and a full FOV of LESS THAN 90 degrees.
/// -> for 90 degrees, the 1st expression should have: ... * 2.0 / 3.0 !!
fn compute_dist_from_screen_and_hfov(width: i32, height: i32) -> (f64, f64) {
    let dist_from_screen = (height as f64) * 2.75 / 3.0;
    assert!(dist_from_screen > 1.0);
    let half_width = (width as f64) / 2.0;
    let hfov = half_width.atan2(dist_from_screen);
    (dist_from_screen, hfov)
}

// NOTE: the palettes of Wolf3D and SOD are different for only 2 colors:
//      166 => RGB(0, 56, 0)
//      167 => RGB(0, 40, 0)
#[inline]
fn palette_to_rgb(c: u8, sod: bool) -> RGB {
    if sod {
        match c {
            166 => {
                return RGB::from(0, 56, 0);
            }
            167 => {
                return RGB::from(0, 40, 0);
            }
            _ => {}
        }
    }
    let idx = (c as usize) * 3;
    RGB::from(PALETTE[idx], PALETTE[idx + 1], PALETTE[idx + 2])
}

const PALETTE: &[u8] = &[
    0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x00, 0xA8, 0x00, 0x00, 0xA8, 0xA8, 0xA8, 0x00, 0x00, 0xA8, 0x00, 0xA8, 0xA8,
    0x54, 0x00, 0xA8, 0xA8, 0xA8, 0x54, 0x54, 0x54, 0x54, 0x54, 0xFF, 0x54, 0xFF, 0x54, 0x54, 0xFF, 0xFF, 0xFF, 0x54,
    0x54, 0xFF, 0x54, 0xFF, 0xFF, 0xFF, 0x54, 0xFF, 0xFF, 0xFF, 0xEC, 0xEC, 0xEC, 0xDC, 0xDC, 0xDC, 0xD0, 0xD0, 0xD0,
    0xC0, 0xC0, 0xC0, 0xB4, 0xB4, 0xB4, 0xA8, 0xA8, 0xA8, 0x98, 0x98, 0x98, 0x8C, 0x8C, 0x8C, 0x7C, 0x7C, 0x7C, 0x70,
    0x70, 0x70, 0x64, 0x64, 0x64, 0x54, 0x54, 0x54, 0x48, 0x48, 0x48, 0x38, 0x38, 0x38, 0x2C, 0x2C, 0x2C, 0x20, 0x20,
    0x20, 0xFF, 0x00, 0x00, 0xEC, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xD4, 0x00, 0x00, 0xC8, 0x00, 0x00, 0xBC, 0x00, 0x00,
    0xB0, 0x00, 0x00, 0xA4, 0x00, 0x00, 0x98, 0x00, 0x00, 0x88, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x70, 0x00, 0x00, 0x64,
    0x00, 0x00, 0x58, 0x00, 0x00, 0x4C, 0x00, 0x00, 0x40, 0x00, 0x00, 0xFF, 0xD8, 0xD8, 0xFF, 0xB8, 0xB8, 0xFF, 0x9C,
    0x9C, 0xFF, 0x7C, 0x7C, 0xFF, 0x5C, 0x5C, 0xFF, 0x40, 0x40, 0xFF, 0x20, 0x20, 0xFF, 0x00, 0x00, 0xFF, 0xA8, 0x5C,
    0xFF, 0x98, 0x40, 0xFF, 0x88, 0x20, 0xFF, 0x78, 0x00, 0xE4, 0x6C, 0x00, 0xCC, 0x60, 0x00, 0xB4, 0x54, 0x00, 0x9C,
    0x4C, 0x00, 0xFF, 0xFF, 0xD8, 0xFF, 0xFF, 0xB8, 0xFF, 0xFF, 0x9C, 0xFF, 0xFF, 0x7C, 0xFF, 0xF8, 0x5C, 0xFF, 0xF4,
    0x40, 0xFF, 0xF4, 0x20, 0xFF, 0xF4, 0x00, 0xE4, 0xD8, 0x00, 0xCC, 0xC4, 0x00, 0xB4, 0xAC, 0x00, 0x9C, 0x9C, 0x00,
    0x84, 0x84, 0x00, 0x70, 0x6C, 0x00, 0x58, 0x54, 0x00, 0x40, 0x40, 0x00, 0xD0, 0xFF, 0x5C, 0xC4, 0xFF, 0x40, 0xB4,
    0xFF, 0x20, 0xA0, 0xFF, 0x00, 0x90, 0xE4, 0x00, 0x80, 0xCC, 0x00, 0x74, 0xB4, 0x00, 0x60, 0x9C, 0x00, 0xD8, 0xFF,
    0xD8, 0xBC, 0xFF, 0xB8, 0x9C, 0xFF, 0x9C, 0x80, 0xFF, 0x7C, 0x60, 0xFF, 0x5C, 0x40, 0xFF, 0x40, 0x20, 0xFF, 0x20,
    0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xEC, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xD4, 0x00, 0x04, 0xC8, 0x00, 0x04,
    0xBC, 0x00, 0x04, 0xB0, 0x00, 0x04, 0xA4, 0x00, 0x04, 0x98, 0x00, 0x04, 0x88, 0x00, 0x04, 0x7C, 0x00, 0x04, 0x70,
    0x00, 0x04, 0x64, 0x00, 0x04, 0x58, 0x00, 0x04, 0x4C, 0x00, 0x04, 0x40, 0x00, 0xD8, 0xFF, 0xFF, 0xB8, 0xFF, 0xFF,
    0x9C, 0xFF, 0xFF, 0x7C, 0xFF, 0xF8, 0x5C, 0xFF, 0xFF, 0x40, 0xFF, 0xFF, 0x20, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00,
    0xE4, 0xE4, 0x00, 0xCC, 0xCC, 0x00, 0xB4, 0xB4, 0x00, 0x9C, 0x9C, 0x00, 0x84, 0x84, 0x00, 0x70, 0x70, 0x00, 0x58,
    0x58, 0x00, 0x40, 0x40, 0x5C, 0xBC, 0xFF, 0x40, 0xB0, 0xFF, 0x20, 0xA8, 0xFF, 0x00, 0x9C, 0xFF, 0x00, 0x8C, 0xE4,
    0x00, 0x7C, 0xCC, 0x00, 0x6C, 0xB4, 0x00, 0x5C, 0x9C, 0xD8, 0xD8, 0xFF, 0xB8, 0xBC, 0xFF, 0x9C, 0x9C, 0xFF, 0x7C,
    0x80, 0xFF, 0x5C, 0x60, 0xFF, 0x40, 0x40, 0xFF, 0x20, 0x24, 0xFF, 0x00, 0x04, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00,
    0xEC, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xD4, 0x00, 0x00, 0xC8, 0x00, 0x00, 0xBC, 0x00, 0x00, 0xB0, 0x00, 0x00, 0xA4,
    0x00, 0x00, 0x98, 0x00, 0x00, 0x88, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x70, 0x00, 0x00, 0x64, 0x00, 0x00, 0x58, 0x00,
    0x00, 0x4C, 0x00, 0x00, 0x40, 0x28, 0x28, 0x28, 0xFF, 0xE0, 0x34, 0xFF, 0xD4, 0x24, 0xFF, 0xCC, 0x18, 0xFF, 0xC0,
    0x08, 0xFF, 0xB4, 0x00, 0xB4, 0x20, 0xFF, 0xA8, 0x00, 0xFF, 0x98, 0x00, 0xE4, 0x80, 0x00, 0xCC, 0x74, 0x00, 0xB4,
    0x60, 0x00, 0x9C, 0x50, 0x00, 0x84, 0x44, 0x00, 0x70, 0x34, 0x00, 0x58, 0x28, 0x00, 0x40, 0xFF, 0xD8, 0xFF, 0xFF,
    0xB8, 0xFF, 0xFF, 0x9C, 0xFF, 0xFF, 0x7C, 0xFF, 0xFF, 0x5C, 0xFF, 0xFF, 0x40, 0xFF, 0xFF, 0x20, 0xFF, 0xFF, 0x00,
    0xFF, 0xE0, 0x00, 0xE4, 0xC8, 0x00, 0xCC, 0xB4, 0x00, 0xB4, 0x9C, 0x00, 0x9C, 0x84, 0x00, 0x84, 0x6C, 0x00, 0x70,
    0x58, 0x00, 0x58, 0x40, 0x00, 0x40, 0xFF, 0xE8, 0xDC, 0xFF, 0xE0, 0xD0, 0xFF, 0xD8, 0xC4, 0xFF, 0xD4, 0xBC, 0xFF,
    0xCC, 0xB0, 0xFF, 0xC4, 0xA4, 0xFF, 0xBC, 0x9C, 0xFF, 0xB8, 0x90, 0xFF, 0xB0, 0x80, 0xFF, 0xA4, 0x70, 0xFF, 0x9C,
    0x60, 0xF0, 0x94, 0x5C, 0xE8, 0x8C, 0x58, 0xDC, 0x88, 0x54, 0xD0, 0x80, 0x50, 0xC8, 0x7C, 0x4C, 0xBC, 0x78, 0x48,
    0xB4, 0x70, 0x44, 0xA8, 0x68, 0x40, 0xA0, 0x64, 0x3C, 0x9C, 0x60, 0x38, 0x90, 0x5C, 0x34, 0x88, 0x58, 0x30, 0x80,
    0x50, 0x2C, 0x74, 0x4C, 0x28, 0x6C, 0x48, 0x24, 0x5C, 0x40, 0x20, 0x54, 0x3C, 0x1C, 0x48, 0x38, 0x18, 0x40, 0x30,
    0x18, 0x38, 0x2C, 0x14, 0x28, 0x20, 0x0C, 0x60, 0x00, 0x64, 0x00, 0x64, 0x64, 0x00, 0x60, 0x60, 0x00, 0x00, 0x1C,
    0x00, 0x00, 0x2C, 0x30, 0x24, 0x10, 0x48, 0x00, 0x48, 0x50, 0x00, 0x50, 0x00, 0x00, 0x34, 0x1C, 0x1C, 0x1C, 0x4C,
    0x4C, 0x4C, 0x5C, 0x5C, 0x5C, 0x40, 0x40, 0x40, 0x30, 0x30, 0x30, 0x34, 0x34, 0x34, 0xD8, 0xF4, 0xF4, 0xB8, 0xE8,
    0xE8, 0x9C, 0xDC, 0xDC, 0x74, 0xC8, 0xC8, 0x48, 0xC0, 0xC0, 0x20, 0xB4, 0xB4, 0x20, 0xB0, 0xB0, 0x00, 0xA4, 0xA4,
    0x00, 0x98, 0x98, 0x00, 0x8C, 0x8C, 0x00, 0x84, 0x84, 0x00, 0x7C, 0x7C, 0x00, 0x78, 0x78, 0x00, 0x74, 0x74, 0x00,
    0x70, 0x70, 0x00, 0x6C, 0x6C, 0xFF, 0x00, 0xFF,
];
