//! Screen bufer - collects what needs to be painted and paints it using the palette.

use crate::{Painter, RGB};

/// Screen buffer - holds one buffer of screen data and paints it on the screen.
pub struct ScreenBuffer {
    width: usize,
    height: usize,
    bytes: Vec<u8>,
    use_sod_palette: bool,
}

impl ScreenBuffer {
    /// Create a new screen buffer.
    pub fn new(width: usize, height: usize, use_sod_palette: bool) -> Self {
        let len = width * height;
        Self {
            width,
            height,
            bytes: vec![0; len],
            use_sod_palette,
        }
    }

    /// Screen buffer width.
    #[inline]
    pub fn width(&self) -> usize {
        self.width
    }

    /// Screen buffer height.
    #[inline]
    pub fn height(&self) -> usize {
        self.height
    }

    /// Put a pixel in the buffer, *with* transparency.
    #[inline]
    pub fn put_pixel(&mut self, x: i32, y: i32, c: u8) {
        if x >= 0 && y >= 0 && c != 0xFF {
            let xx = x as usize;
            let yy = y as usize;
            if xx < self.width && yy < self.height {
                let idx = yy * self.width + xx;
                self.bytes[idx] = c;
            }
        }
    }

    /// Fill a rectangle inside the buffer, *without* transparency.
    pub fn fill_rect(&mut self, x: i32, y: i32, w: i32, h: i32, c: u8) {
        let isw = self.width as i32;
        let ish = self.height as i32;
        if w <= 0 || h <= 0 || x >= isw || y >= ish {
            return;
        }

        // shift top-left corner inside the screen
        let xx = Ord::max(x, 0);
        let yy = Ord::max(y, 0);
        let w = w - xx + x;
        let h = h - yy + y;
        if w <= 0 || h <= 0 {
            return;
        }

        // shift bottom right corner inside the screen
        let sw = Ord::min(w, isw - xx) as usize;
        let sh = Ord::min(h, ish - yy) as usize;
        let mut idx = (yy * isw + xx) as usize;
        let step = self.width - sw;

        // ok to paint
        for _ in 0..sh {
            for _ in 0..sw {
                self.bytes[idx] = c;
                idx += 1;
            }
            idx += step;
        }
    }

    /// Paint the buffer onto the screen.
    pub fn paint(&self, painter: &mut dyn Painter) {
        let mut idx = 0;
        for y in 0..(self.height as i32) {
            for x in 0..(self.width as i32) {
                let color = palette_to_rgb(self.bytes[idx], self.use_sod_palette);
                painter.draw_pixel(x, y, color);
                idx += 1;
            }
        }
    }
}

//--------------------------
//  Internal stuff

// NOTE: the palettes of Wolf3D and SOD are different for only 2 colors:
//      166 => RGB(0, 56, 0)
//      167 => RGB(0, 40, 0)
#[inline]
fn palette_to_rgb(c: u8, sod: bool) -> RGB {
    if sod {
        match c {
            166 => {
                return RGB::from(0, 56, 0);
            }
            167 => {
                return RGB::from(0, 40, 0);
            }
            _ => {}
        }
    }
    let idx = (c as usize) * 3;
    RGB::from(PALETTE[idx], PALETTE[idx + 1], PALETTE[idx + 2])
}

const PALETTE: &[u8] = &[
    0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x00, 0xA8, 0x00, 0x00, 0xA8, 0xA8, 0xA8, 0x00, 0x00, 0xA8, 0x00, 0xA8, 0xA8,
    0x54, 0x00, 0xA8, 0xA8, 0xA8, 0x54, 0x54, 0x54, 0x54, 0x54, 0xFF, 0x54, 0xFF, 0x54, 0x54, 0xFF, 0xFF, 0xFF, 0x54,
    0x54, 0xFF, 0x54, 0xFF, 0xFF, 0xFF, 0x54, 0xFF, 0xFF, 0xFF, 0xEC, 0xEC, 0xEC, 0xDC, 0xDC, 0xDC, 0xD0, 0xD0, 0xD0,
    0xC0, 0xC0, 0xC0, 0xB4, 0xB4, 0xB4, 0xA8, 0xA8, 0xA8, 0x98, 0x98, 0x98, 0x8C, 0x8C, 0x8C, 0x7C, 0x7C, 0x7C, 0x70,
    0x70, 0x70, 0x64, 0x64, 0x64, 0x54, 0x54, 0x54, 0x48, 0x48, 0x48, 0x38, 0x38, 0x38, 0x2C, 0x2C, 0x2C, 0x20, 0x20,
    0x20, 0xFF, 0x00, 0x00, 0xEC, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xD4, 0x00, 0x00, 0xC8, 0x00, 0x00, 0xBC, 0x00, 0x00,
    0xB0, 0x00, 0x00, 0xA4, 0x00, 0x00, 0x98, 0x00, 0x00, 0x88, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x70, 0x00, 0x00, 0x64,
    0x00, 0x00, 0x58, 0x00, 0x00, 0x4C, 0x00, 0x00, 0x40, 0x00, 0x00, 0xFF, 0xD8, 0xD8, 0xFF, 0xB8, 0xB8, 0xFF, 0x9C,
    0x9C, 0xFF, 0x7C, 0x7C, 0xFF, 0x5C, 0x5C, 0xFF, 0x40, 0x40, 0xFF, 0x20, 0x20, 0xFF, 0x00, 0x00, 0xFF, 0xA8, 0x5C,
    0xFF, 0x98, 0x40, 0xFF, 0x88, 0x20, 0xFF, 0x78, 0x00, 0xE4, 0x6C, 0x00, 0xCC, 0x60, 0x00, 0xB4, 0x54, 0x00, 0x9C,
    0x4C, 0x00, 0xFF, 0xFF, 0xD8, 0xFF, 0xFF, 0xB8, 0xFF, 0xFF, 0x9C, 0xFF, 0xFF, 0x7C, 0xFF, 0xF8, 0x5C, 0xFF, 0xF4,
    0x40, 0xFF, 0xF4, 0x20, 0xFF, 0xF4, 0x00, 0xE4, 0xD8, 0x00, 0xCC, 0xC4, 0x00, 0xB4, 0xAC, 0x00, 0x9C, 0x9C, 0x00,
    0x84, 0x84, 0x00, 0x70, 0x6C, 0x00, 0x58, 0x54, 0x00, 0x40, 0x40, 0x00, 0xD0, 0xFF, 0x5C, 0xC4, 0xFF, 0x40, 0xB4,
    0xFF, 0x20, 0xA0, 0xFF, 0x00, 0x90, 0xE4, 0x00, 0x80, 0xCC, 0x00, 0x74, 0xB4, 0x00, 0x60, 0x9C, 0x00, 0xD8, 0xFF,
    0xD8, 0xBC, 0xFF, 0xB8, 0x9C, 0xFF, 0x9C, 0x80, 0xFF, 0x7C, 0x60, 0xFF, 0x5C, 0x40, 0xFF, 0x40, 0x20, 0xFF, 0x20,
    0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xEC, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xD4, 0x00, 0x04, 0xC8, 0x00, 0x04,
    0xBC, 0x00, 0x04, 0xB0, 0x00, 0x04, 0xA4, 0x00, 0x04, 0x98, 0x00, 0x04, 0x88, 0x00, 0x04, 0x7C, 0x00, 0x04, 0x70,
    0x00, 0x04, 0x64, 0x00, 0x04, 0x58, 0x00, 0x04, 0x4C, 0x00, 0x04, 0x40, 0x00, 0xD8, 0xFF, 0xFF, 0xB8, 0xFF, 0xFF,
    0x9C, 0xFF, 0xFF, 0x7C, 0xFF, 0xF8, 0x5C, 0xFF, 0xFF, 0x40, 0xFF, 0xFF, 0x20, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00,
    0xE4, 0xE4, 0x00, 0xCC, 0xCC, 0x00, 0xB4, 0xB4, 0x00, 0x9C, 0x9C, 0x00, 0x84, 0x84, 0x00, 0x70, 0x70, 0x00, 0x58,
    0x58, 0x00, 0x40, 0x40, 0x5C, 0xBC, 0xFF, 0x40, 0xB0, 0xFF, 0x20, 0xA8, 0xFF, 0x00, 0x9C, 0xFF, 0x00, 0x8C, 0xE4,
    0x00, 0x7C, 0xCC, 0x00, 0x6C, 0xB4, 0x00, 0x5C, 0x9C, 0xD8, 0xD8, 0xFF, 0xB8, 0xBC, 0xFF, 0x9C, 0x9C, 0xFF, 0x7C,
    0x80, 0xFF, 0x5C, 0x60, 0xFF, 0x40, 0x40, 0xFF, 0x20, 0x24, 0xFF, 0x00, 0x04, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00,
    0xEC, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xD4, 0x00, 0x00, 0xC8, 0x00, 0x00, 0xBC, 0x00, 0x00, 0xB0, 0x00, 0x00, 0xA4,
    0x00, 0x00, 0x98, 0x00, 0x00, 0x88, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x70, 0x00, 0x00, 0x64, 0x00, 0x00, 0x58, 0x00,
    0x00, 0x4C, 0x00, 0x00, 0x40, 0x28, 0x28, 0x28, 0xFF, 0xE0, 0x34, 0xFF, 0xD4, 0x24, 0xFF, 0xCC, 0x18, 0xFF, 0xC0,
    0x08, 0xFF, 0xB4, 0x00, 0xB4, 0x20, 0xFF, 0xA8, 0x00, 0xFF, 0x98, 0x00, 0xE4, 0x80, 0x00, 0xCC, 0x74, 0x00, 0xB4,
    0x60, 0x00, 0x9C, 0x50, 0x00, 0x84, 0x44, 0x00, 0x70, 0x34, 0x00, 0x58, 0x28, 0x00, 0x40, 0xFF, 0xD8, 0xFF, 0xFF,
    0xB8, 0xFF, 0xFF, 0x9C, 0xFF, 0xFF, 0x7C, 0xFF, 0xFF, 0x5C, 0xFF, 0xFF, 0x40, 0xFF, 0xFF, 0x20, 0xFF, 0xFF, 0x00,
    0xFF, 0xE0, 0x00, 0xE4, 0xC8, 0x00, 0xCC, 0xB4, 0x00, 0xB4, 0x9C, 0x00, 0x9C, 0x84, 0x00, 0x84, 0x6C, 0x00, 0x70,
    0x58, 0x00, 0x58, 0x40, 0x00, 0x40, 0xFF, 0xE8, 0xDC, 0xFF, 0xE0, 0xD0, 0xFF, 0xD8, 0xC4, 0xFF, 0xD4, 0xBC, 0xFF,
    0xCC, 0xB0, 0xFF, 0xC4, 0xA4, 0xFF, 0xBC, 0x9C, 0xFF, 0xB8, 0x90, 0xFF, 0xB0, 0x80, 0xFF, 0xA4, 0x70, 0xFF, 0x9C,
    0x60, 0xF0, 0x94, 0x5C, 0xE8, 0x8C, 0x58, 0xDC, 0x88, 0x54, 0xD0, 0x80, 0x50, 0xC8, 0x7C, 0x4C, 0xBC, 0x78, 0x48,
    0xB4, 0x70, 0x44, 0xA8, 0x68, 0x40, 0xA0, 0x64, 0x3C, 0x9C, 0x60, 0x38, 0x90, 0x5C, 0x34, 0x88, 0x58, 0x30, 0x80,
    0x50, 0x2C, 0x74, 0x4C, 0x28, 0x6C, 0x48, 0x24, 0x5C, 0x40, 0x20, 0x54, 0x3C, 0x1C, 0x48, 0x38, 0x18, 0x40, 0x30,
    0x18, 0x38, 0x2C, 0x14, 0x28, 0x20, 0x0C, 0x60, 0x00, 0x64, 0x00, 0x64, 0x64, 0x00, 0x60, 0x60, 0x00, 0x00, 0x1C,
    0x00, 0x00, 0x2C, 0x30, 0x24, 0x10, 0x48, 0x00, 0x48, 0x50, 0x00, 0x50, 0x00, 0x00, 0x34, 0x1C, 0x1C, 0x1C, 0x4C,
    0x4C, 0x4C, 0x5C, 0x5C, 0x5C, 0x40, 0x40, 0x40, 0x30, 0x30, 0x30, 0x34, 0x34, 0x34, 0xD8, 0xF4, 0xF4, 0xB8, 0xE8,
    0xE8, 0x9C, 0xDC, 0xDC, 0x74, 0xC8, 0xC8, 0x48, 0xC0, 0xC0, 0x20, 0xB4, 0xB4, 0x20, 0xB0, 0xB0, 0x00, 0xA4, 0xA4,
    0x00, 0x98, 0x98, 0x00, 0x8C, 0x8C, 0x00, 0x84, 0x84, 0x00, 0x7C, 0x7C, 0x00, 0x78, 0x78, 0x00, 0x74, 0x74, 0x00,
    0x70, 0x70, 0x00, 0x6C, 0x6C, 0xFF, 0x00, 0xFF,
];

/*
// (TEMP) load palette from GAMEPAL.OBJ
pub fn _temp_load_palette() {
    let mut idx = 0x77;
    let pal = get_file_as_byte_vec("GAMEPAL.OBJ");
    for _ in 0..256 {
        // input range is 0..63 => map it to 0..255
        let r = pal[idx] << 2;
        let g = pal[idx + 1] << 2;
        let b = pal[idx + 2] << 2;
        idx += 3;
        println!("   0x{r:02X}, 0x{g:02X}, 0x{b:02X},")
    }
}

fn get_file_as_byte_vec(filename: &str) -> Vec<u8> {
    let mut f = std::fs::File::open(&filename).expect("no file found");
    let metadata = std::fs::metadata(&filename).expect("unable to read metadata");
    let mut buffer = vec![0; metadata.len() as usize];

    use std::io::Read;
    f.read(&mut buffer).expect("buffer overflow");

    buffer
}
// */
